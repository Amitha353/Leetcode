import java.util.*;

class Main {
  public static void main(String[] args) {
    String[] sentences = {"i love you", "island", "ironman","i love leetcode"};
		int[] times = {5, 3, 2, 2};
     AutocompleteSystem obj = new AutocompleteSystem(sentences, times);
     List<String> params = obj.input(' ');
     for(String p: params) {
       System.out.println(p);
     }
  }
}

class AutocompleteSystem {
   class TrieNode {
        public boolean isEnd;
        public Map<String, Integer> freq;
        public Map<Character, TrieNode> children; // Map is more applicable to all chars, not limited to 256 ASCII
        public TrieNode() {
            this.freq = new HashMap<>();
            this.children = new HashMap<>();
        }
    }
    class Pair {
        String s;
        int count;
        public Pair(String s, int count) {
            this.s = s;
            this.count = count;
        }
    }
    TrieNode root, curr;
    StringBuffer sb;
    public AutocompleteSystem(String[] sentences, int[] times) {
        if (sentences == null || times == null || sentences.length != times.length) return;
        reset();
        root = new TrieNode();
        for (int i = 0; i < times.length; i++) {
            insert(sentences[i], times[i]);
        }
    }
    
    public List<String> input(char c) {
        List<String> rst = new ArrayList<>();
        if (curr == null) curr = root;
        if (c == '#') { // save sentence and reset state
            insert(sb.toString(), 1);
            reset();
            return rst;
        }
        
        // Update global variable (curr TrieNode and string buffer); or append new character if not exist.
        sb.append(c);
        curr.children.putIfAbsent(c, new TrieNode());
        curr = curr.children.get(c);

        // MinHeap to find top 3.
        rst.addAll(findTopK(curr, 3));
        
        return rst;
    }
    
    private List<String> findTopK(TrieNode node, int k) {
        List<String> rst = new ArrayList<>();
        if (node.freq.isEmpty()) return rst;
        PriorityQueue<Pair> queue = new PriorityQueue<>(
            (a, b) -> a.count == b.count ? b.s.compareTo(a.s) : a.count - b.count);
        for (Map.Entry<String, Integer> entry : node.freq.entrySet()) {
            if (queue.size() < 3 || entry.getValue() >= queue.peek().count) {
                queue.offer(new Pair(entry.getKey(), entry.getValue()));
            }
            if (queue.size() > 3) queue.poll();
        }
        
        while (!queue.isEmpty()) {
            rst.add(0, queue.poll().s);
        }
        
        return rst;
    }
    
    private void reset() {
        curr = null;
        sb = new StringBuffer();
    }
    
    private void insert(String sentence, int count) {
        if (sentence == null || sentence.length() == 0) return;
        TrieNode node = root;
        for (char c : sentence.toCharArray()) {
            node.children.putIfAbsent(c, new TrieNode());
            node = node.children.get(c);
            node.freq.put(sentence, node.freq.getOrDefault(sentence, 0) + count);
        }
        node.isEnd = true; // can set word to node as well, if needed
    }
}

/*
tags: Design, Trie, Hash Table, MinHeap, PriorityQueue
time: input: O(x), where x = possible words, constructor: O(mn) m = max length, n = # of words
space: O(n^2), n = # of possible words, n = # of trie levels; mainlay saving the `Map<S, freq>`
*/
